
fibonacci(n) { 

if n==0 {
return 1 
}
else{
return  n*fibonacci(n-1)
}

}


control list , rest is same . 
do stack via list 
do queue via list 
do double list via list 
do tree via list 
list plus recursion is all it takes 

public LinkedList{

LinkedList next ; 
Integer data ; 

pubilc LinkedList(data){
this.data = data ; 
}

set method for data 
get method for data 
set method for list 
get method for list 

}

insert(head , n,data ) {
temp=head ; 
n=0
while(temp.next!= null ) {
n++;
if( m==n){
nextNode = temp.next ; 
newNode = new LinkedList(data ) ; 
temp.next = newNode; 
newNode.next = nextNode ; 

}

}




package dsAlgo;

public class SingleLinkedList {
	
	
	Integer data ; 
	SingleLinkedList next ; 
	
	public SingleLinkedList(Integer data) {
		this.data = data ; 
	}

	public Integer getData() {
		return data;
	}

	public void setData(Integer data) {
		this.data = data;
	}

	public SingleLinkedList getNext() {
		return next;
	}

	public void setNext(SingleLinkedList next) {
		this.next = next;
	}
	
	
	
	public void traverseNodes(SingleLinkedList head) {
		SingleLinkedList temp = head ; 
		while((temp.getNext()!=null) || (temp.getNext()==null)) {
			System.out.println("data is : "+temp.getData());
			if(temp!=null) {
			temp = temp.getNext();
			}
			if(temp==null) {
				break;
			}
//			System.out.println("data is : "+temp.getData());
		}
	}
	
	public static void main(String[] args) {
		SingleLinkedList newNode = new SingleLinkedList(10);
		SingleLinkedList nextNode = new SingleLinkedList(20);
		newNode.setNext(nextNode);
		nextNode.setNext(null);
		newNode.traverseNodes(newNode);		
		
		
	}

}


/*
 * output is
 * 
 * data is : 10 data is : 20
 */


 ------------------

 in non linear search   for searching you iterate the entire array and try to do the match . 

In sorted array , you keep matching , but if the arary value gets bigger than the value to be matched , in that case , you return -1 

binary search , applicable to searching in sorted data , 

while( low is less than high) 
{
mid = low plus high by 2 
if data is equal to mid , found . 
else if data is less than mid , 
then , high = mid - 1
else if data is more than mid , 
then low = mid + 1

}

check duplicates 

for int i=0 ; i++ , 
for j=i+2; j+++,
if a of i is equal to a of j , 
then duplicate 
and so on .. 

if we improve it , then , 
for int i=0;i++
if a of i is equal to a of i+1

check if in array if two elements sum is equal to element k 
for i -0;i++
for j=i+1;j++

if a of i plus a of j is equal to k . 

Similar above goes for three elements whose sum is equal to k . 
Just that j is i plus 1 , and k is j plus 1 . 



------------------------

